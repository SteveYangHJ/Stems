# 5. The IoC container

标签（空格分隔）： Spring3.2.16

---

## 5.1. Introduction to the Spring IoC container and beans
## 5.2. Container overview
### 5.2.1. Configuration metadata
### 5.2.2. Instantiating a container
Composing XML-based configuration metadata
### 5.2.3. Using the container
## 5.3. Bean overview
### 5.3.1. Naming beans
Aliasing a bean outside the bean definition
### 5.3.2. Instantiating beans
Instantiation with a constructor
Instantiation with a static factory method
Instantiation using an instance factory method
## 5.4. Dependencies
### 5.4.1. Dependency injection
Constructor-based dependency injection
Setter-based dependency injection
Dependency resolution process
Examples of dependency injection
### 5.4.2. Dependencies and configuration in detail
Straight values (primitives, Strings, and so on)
References to other beans (collaborators)
Inner beans
Collections
Null and empty string values
XML shortcut with the p-namespace
XML shortcut with the c-namespace
Compound property names
### 5.4.3. Using depends-on
### 5.4.4. Lazy-initialized beans
### 5.4.5. Autowiring collaborators
Limitations and disadvantages of autowiring
Excluding a bean from autowiring
### 5.4.6. Method injection
Lookup method injection
Arbitrary method replacement
## 5.5. Bean scopes
### 5.5.1. The singleton scope
### 5.5.2. The prototype scope
### 5.5.3. Singleton beans with prototype-bean dependencies
### 5.5.4. Request, session, and global session scopes
Initial web configuration
Request scope
Session scope
Global session scope
Scoped beans as dependencies
### 5.5.5. Custom scopes
Creating a custom scope
Using a custom scope
## 5.6. Customizing the nature of a bean
### 5.6.1. Lifecycle callbacks
Initialization callbacks
Destruction callbacks
Default initialization and destroy methods
Combining lifecycle mechanisms
Startup and shutdown callbacks
Shutting down the Spring IoC container gracefully in non-web applications
### 5.6.2. ApplicationContextAware and BeanNameAware
### 5.6.3. Other Aware interfaces
## 5.7. Bean definition inheritance
## 5.8. Container Extension Points
### 5.8.1. Customizing beans using a BeanPostProcessor
Example: Hello World, BeanPostProcessor-style
Example: The RequiredAnnotationBeanPostProcessor
### 5.8.2. Customizing configuration metadata with a BeanFactoryPostProcessor
Example: the PropertyPlaceholderConfigurer
Example: the PropertyOverrideConfigurer
### 5.8.3. Customizing instantiation logic with a FactoryBean
## 5.9. Annotation-based container configuration
### 5.9.1. @Required
### 5.9.2. @Autowired
### 5.9.3. Fine-tuning annotation-based autowiring with qualifiers
### 5.9.4. CustomAutowireConfigurer
### 5.9.5. @Resource
### 5.9.6. @PostConstruct and @PreDestroy
## 5.10. Classpath scanning and managed components
### 5.10.1. @Component and further stereotype annotations
### 5.10.2. Automatically detecting classes and registering bean definitions
### 5.10.3. Using filters to customize scanning
### 5.10.4. Defining bean metadata within components
### 5.10.5. Naming autodetected components
### 5.10.6. Providing a scope for autodetected components
### 5.10.7. Providing qualifier metadata with annotations
## 5.11. Using JSR 330 Standard Annotations
### 5.11.1. Dependency Injection with @Inject and @Named
### 5.11.2. @Named: a standard equivalent to the @Component annotation
### 5.11.3. Limitations of the standard approach
## 5.12. Java-based container configuration
### 5.12.1. Basic concepts: @Bean and @Configuration
### 5.12.2. Instantiating the Spring container using AnnotationConfigApplicationContext
Simple construction
Building the container programmatically using register(Class<?>...)
Enabling component scanning with scan(String...)
Support for web applications with AnnotationConfigWebApplicationContext
### 5.12.3. Using the @Bean annotation
Declaring a bean
Receiving lifecycle callbacks
Specifying bean scope
Customizing bean naming
Bean aliasing
### 5.12.4. Using the @Configuration annotation
Injecting inter-bean dependencies
Lookup method injection
Further information about how Java-based configuration works internally
### 5.12.5. Composing Java-based configurations
Using the @Import annotation
Combining Java and XML configuration
## 5.13. Registering a LoadTimeWeaver
## 5.14. Additional Capabilities of the ApplicationContext
### 5.14.1. Internationalization using MessageSource
### 5.14.2. Standard and Custom Events
### 5.14.3. Convenient access to low-level resources
### 5.14.4. Convenient ApplicationContext instantiation for web applications
### 5.14.5. Deploying a Spring ApplicationContext as a J2EE RAR file
## 5.15. The BeanFactory
### 5.15.1. BeanFactory or ApplicationContext?
### 5.15.2. Glue code and the evil singleton



